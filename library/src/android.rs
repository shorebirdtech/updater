use anyhow::Context;
use std::fs;
use std::io::{Cursor, Read};
use std::path::{Path, PathBuf};

// https://stackoverflow.com/questions/67087597/is-it-possible-to-use-rusts-log-info-for-tests
#[cfg(test)]
use std::println as debug; // Workaround to use println! for logs.

pub(crate) fn app_data_dir_from_libapp_path(libapp_path: &str) -> anyhow::Result<PathBuf> {
    // "/data/app/~~7LtReIkm5snW_oXeDoJ5TQ==/com.example.shorebird_test-rpkDZSLBRv2jWcc1gQpwdg==/lib/x86_64/libapp.so"
    let path = PathBuf::from(libapp_path);
    let root = path.ancestors().nth(3).context("Invalid libapp path")?;
    Ok(PathBuf::from(root))
}

struct ArchNames {
    apk_split: &'static str,
    lib_dir: &'static str,
}

fn android_arch_names() -> &'static ArchNames {
    // This was generated by looking at what apk splits are generated by
    // bundletool.
    // https://developer.android.com/ndk/guides/abis
    #[cfg(target_arch = "x86")]
    static ARCH: ArchNames = ArchNames {
        apk_split: "x86",
        lib_dir: "x86",
    };
    #[cfg(target_arch = "x86_64")]
    // x86_64 uses _ for both split and library paths.
    static ARCH: ArchNames = ArchNames {
        apk_split: "x86_64", // e.g. standalone-x86_64_hdpi.apk
        lib_dir: "x86_64",   // e.g. lib/x86_64/libapp.so
    };
    #[cfg(target_arch = "aarch64")]
    // Note the _ in the split name, but the - in the lib dir.
    static ARCH: ArchNames = ArchNames {
        apk_split: "arm64_v8a",
        lib_dir: "arm64-v8a",
    };
    #[cfg(target_arch = "arm")]
    // Note the _ in the split name, but the - in the lib dir.
    static ARCH: ArchNames = ArchNames {
        apk_split: "armeabi_v7a", // e.g. base-armeabi_v7a.apk
        lib_dir: "armeabi-v7a",   // e.g. lib/armeabi-v7a/libapp.so
    };
    return &ARCH;
}

/// This is public only for testing.
pub(crate) fn get_relative_lib_path(lib_name: &str) -> PathBuf {
    PathBuf::from("lib")
        .join(android_arch_names().lib_dir)
        .join(lib_name)
}

// This is just a tuple of the archive and the internal path to the library.
// Ideally we'd just return the ZipFile itself, but I don't know how to set
// up the references correctly, ZipFile contains a borrow into the ZipArchive.
// And I'm not the right Rust to keep a reference to both with proper lifetimes.
#[derive(Debug)]
struct ZipLocation {
    archive: zip::ZipArchive<fs::File>,
    internal_path: String,
}

fn check_for_lib_path(zip_path: &Path, lib_path: &str) -> anyhow::Result<ZipLocation> {
    let apk = zip::ZipArchive::new(fs::File::open(zip_path)?)?;
    if apk.file_names().any(|name| name == lib_path) {
        return Ok(ZipLocation {
            archive: apk,
            internal_path: lib_path.to_owned(),
        });
    }
    return Err(anyhow::anyhow!("Library not found in APK"));
}

/// Given a directory of APKs, find the one that contains the library we want.
/// This has to be done due to split APKs.
fn find_and_open_lib(apks_dir: &Path, lib_name: &str) -> anyhow::Result<ZipLocation> {
    // Read the library out of the APK.  We only really need to do this if it
    // isn't already extracted on disk (which it won't be by default from the
    // play store).

    // First check ones with our arch in the name, in any order.
    let arch = android_arch_names();
    let lib_path = get_relative_lib_path(lib_name)
        .to_str()
        .context("Invalid lib path")?
        .to_owned();

    for entry in fs::read_dir(apks_dir)? {
        let entry = entry?;
        let path = entry.path(); // returns the absolute path.
        if path.is_dir() {
            continue;
        }
        // Using match to avoid unwrap possibly panicking.
        match path.file_name() {
            None => continue,
            Some(filename) => match filename.to_str() {
                None => continue,
                Some(filename) => {
                    if !filename.ends_with(".apk") {
                        continue;
                    }
                    if !filename.contains(arch.apk_split) {
                        debug!("Ignoring APK: {:?}", path);
                        continue;
                    }
                }
            },
        }
        debug!("Checking APK split: {:?}", path);
        if let Ok(zip) = check_for_lib_path(&path, &lib_path) {
            debug!("Found lib in apk split: {:?}", path);
            return Ok(zip);
        }
    }
    let base_apk_path = apks_dir.join("base.apk");
    debug!("Checking base APK: {:?}", base_apk_path);
    return check_for_lib_path(&base_apk_path, &lib_path);
}

pub(crate) fn open_base_lib(apks_dir: &Path, lib_name: &str) -> anyhow::Result<Cursor<Vec<u8>>> {
    // As far as I can tell, Android provides no apis for reading per-platform
    // assets (e.g. libapp.so) from an APK.  Both Facebook and Chromium
    // seem to have written their own code to do this:
    // https://github.com/facebook/SoLoader/blob/main/java/com/facebook/soloader/DirectApkSoSource.java
    // https://chromium.googlesource.com/chromium/src/base/+/a5ca5def0453df367b9c42e9817a33d2a21e75fe/android/java/src/org/chromium/base/library_loader/Linker.java
    // Previously I tried reading libapp.so from from the AssetManager, but
    // it does show the lib/ directory in the list of assets.
    // https://github.com/shorebirdtech/updater/pull/6

    // Ideally we would do this apk reading from the C++ side and keep the rust
    // portable, but we have a zip library here, and don't on the C++ side.

    let mut zip_location = find_and_open_lib(apks_dir, lib_name)?;
    let mut zip_file = zip_location
        .archive
        .by_name(&zip_location.internal_path)
        .context("Failed to find libapp.so in APK")?;

    // Cursor (rather than ZipFile) is only necessary because bipatch expects
    // Seek + Read for the input file.  I don't think it actually needs to
    // seek backwards, so Read is probably sufficient.  If we made bipatch
    // only depend on Read we could avoid loading the library fully into memory.
    let mut buffer = Vec::new();
    zip_file.read_to_end(&mut buffer)?;
    Ok(Cursor::new(buffer))
}

#[cfg(target_os = "android")]
fn libapp_path_from_settings(original_libapp_paths: Vec<String>) -> anyhow::Result<PathBuf> {
    // FIXME: This makes the assumption that the last path provided is the full
    // path to the libapp.so file.  This is true for the current engine, but
    // may not be true in the future.  Better would be for the engine to
    // pass us the path to the base.apk.
    // https://github.com/shorebirdtech/shorebird/issues/283
    // This is where the paths are set today:
    // First path is "libapp.so" (for dlopen), second is a full path:
    // https://github.com/flutter/engine/blob/a7c9cc58a71c5850be0215ab1997db92cc5e8d3e/shell/platform/android/io/flutter/embedding/engine/loader/FlutterLoader.java#L264
    // Which is composed from nativeLibraryDir:
    // https://developer.android.com/reference/android/content/pm/ApplicationInfo#nativeLibraryDir
    let full_libapp_path = original_libapp_paths.last().context("No libapp paths")?;
    // We could probably use sourceDir instead?
    // https://developer.android.com/reference/android/content/pm/ApplicationInfo#sourceDir
    // and splitSourceDirs (api 21+)
    // https://developer.android.com/reference/android/content/pm/ApplicationInfo#splitSourceDirs
    debug!("Finding apk from: {:?}", full_libapp_path);
    app_data_dir_from_libapp_path(full_libapp_path)
}

// These are mostly stub tests to prevent warnings about unused fields.
#[cfg(test)]
mod tests {
    use tempdir::TempDir;

    #[test]
    fn find_and_open_lib_test() {
        let tmp_dir = TempDir::new("example").unwrap();
        let error = super::find_and_open_lib(tmp_dir.path(), "libapp.so").unwrap_err();
        assert!(error.to_string().contains("No such file or directory"));
    }

    #[test]
    fn app_data_dir_from_libapp_path_test() {
        let path = "/data/app/~~7LtReIkm5snW_oXeDoJ5TQ==/com.example.shorebird_test-rpkDZSLBRv2jWcc1gQpwdg==/lib/x86_64/libapp.so";
        let dir = super::app_data_dir_from_libapp_path(path).unwrap();
        assert_eq!(
            dir,
            std::path::PathBuf::from("/data/app/~~7LtReIkm5snW_oXeDoJ5TQ==/com.example.shorebird_test-rpkDZSLBRv2jWcc1gQpwdg==")
        );
    }

    #[test]
    fn open_base_lib_test() {
        let tmp_dir = TempDir::new("example").unwrap();
        let error = super::open_base_lib(tmp_dir.path(), "libapp.so").unwrap_err();
        assert!(error.to_string().contains("No such file or directory"));
    }
}
